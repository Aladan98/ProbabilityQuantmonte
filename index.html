<html>
<head>
<title>Quant Analyzer</title>
<style>
body{font-family:monospace;background:#111;color:#eee;margin:0;padding:10px;}
input,button,select{margin:2px;padding:5px;background:#222;color:#eee;border:1px solid #555;}
button{cursor:pointer;}
table{border-collapse:collapse;width:100%;margin:5px 0;}
th,td{border:1px solid #555;padding:5px;font-size:12px;}
th{background:#333;color:#0cf;}
.up{color:#4caf50;font-weight:bold;}
.down{color:#f44336;font-weight:bold;}
</style>
</head>
<body>

<h1>Quant Multi-Timeframe Analyzer</h1>

<input type="file" id="csvFile" accept=".csv"/>
<input type="number" id="yearFilter" placeholder="Year (optional)"/>
<button onclick="loadCSVData()">Load CSV</button>
<button onclick="analyzeData()">Analyze</button>
<button onclick="downloadCSV()">Download CSV</button>

<div id="bestDays">Best Days Table...</div>
<div id="results">Clusters Table...</div>
<div id="nextDayForecast">Next-Day Forecast...</div>
<div id="weeklyForecast">Weekly Forecast...</div>
<div id="monthlyForecast">Monthly Forecast...</div>

<script>
let csvData=[],clusterArrayGlobal=[];
const maxDaysForExpectedReturn=[1,3,5,10];

document.getElementById('csvFile').addEventListener('change',e=>{
  const file=e.target.files[0];
  if(!file)return;
  const reader=new FileReader();
  reader.onload=evt=>parseCSV(evt.target.result);
  reader.readAsText(file);
});

function parseCSV(txt){
  const lines=txt.trim().split('\n');
  const headers=lines[0].toLowerCase().split(',').map(h=>h.trim());
  const dateIndex=headers.findIndex(h=>h.includes('date')||h.includes('time'));
  const openIndex=headers.findIndex(h=>h.includes('open'));
  const highIndex=headers.findIndex(h=>h.includes('high'));
  const lowIndex=headers.findIndex(h=>h.includes('low'));
  const closeIndex=headers.findIndex(h=>h.includes('close'));
  if([dateIndex,openIndex,highIndex,lowIndex,closeIndex].includes(-1)){alert('CSV missing columns');return;}
  csvData=[];
  for(let i=1;i<lines.length;i++){
    const vals=lines[i].split(',').map(v=>v.trim());
    const row={date:vals[dateIndex],open:parseFloat(vals[openIndex]),high:parseFloat(vals[highIndex]),low:parseFloat(vals[lowIndex]),close:parseFloat(vals[closeIndex])};
    if(!isNaN(row.open))csvData.push(row);
  }
  alert(`Loaded ${csvData.length} rows.`);
}

function loadCSVData(){ if(!csvData.length){alert('Load CSV first');return;} alert(`${csvData.length} rows ready.`); }

function computeExpectedRange(clusterPrice,history){
  let highs=history.map(d=>d.high-d.dailyAvg),lows=history.map(d=>d.dailyAvg-d.low);
  let meanH=highs.reduce((a,b)=>a+b,0)/highs.length||0;
  let meanL=lows.reduce((a,b)=>a+b,0)/lows.length||0;
  return {expectedHigh:(parseFloat(clusterPrice)+meanH).toFixed(4),expectedLow:(parseFloat(clusterPrice)-meanL).toFixed(4)};
}

function computeProbabilisticRange(history,futureDays=5){
  let rets=history.map((d,i)=>i+futureDays<history.length?(history[i+futureDays].close-d.dailyAvg)/d.dailyAvg:0).sort((a,b)=>a-b);
  let n=rets.length;
  return {low25:rets[Math.floor(0.25*n)]||0,median50:rets[Math.floor(0.5*n)]||0,high75:rets[Math.floor(0.75*n)]||0};
}

function analyzeData(){
  const yearF=document.getElementById('yearFilter').value.trim();
  if(!csvData.length){alert('Load CSV first');return;}
  let clustersDaily={},clustersWeekly={},clustersMonthly={},bestDays=[],rangeHist=[],prevClose=null,trueRanges=[];
  let weeklyMap={},monthlyMap={};
  let sortedRows=csvData.map(r=>({...r,dateObj:new Date(r.date)})).sort((a,b)=>a.dateObj-b.dateObj);
  
  function getWeekNumber(d){d=new Date(d.getTime());d.setHours(0,0,0,0);d.setDate(d.getDate()+4-(d.getDay()||7)); let start=new Date(d.getFullYear(),0,1); return Math.ceil((((d-start)/86400000)+1)/7);}
  function getMonth(d){return d.getMonth()+1;}
  
  sortedRows.forEach((r,i)=>{
    if(yearF && r.dateObj.getFullYear()!=parseInt(yearF)) return;
    r.dailyAvg=(r.open+r.high+r.low+r.close)/4;
    r.dailyRange=r.high-r.low;
    r.direction=r.close>r.open?"Up":"Down";
    r.momentum1=i>=1?(r.close-sortedRows[i-1].close)/sortedRows[i-1].close:0;
    r.momentum3=i>=3?(r.close-sortedRows[i-3].close)/sortedRows[i-3].close:0;
    r.momentum5=i>=5?(r.close-sortedRows[i-5].close)/sortedRows[i-5].close:0;
    r.momentum10=i>=10?(r.close-sortedRows[i-10].close)/sortedRows[i-10].close:0;
    maxDaysForExpectedReturn.forEach(dN=>{if(i+dN<sortedRows.length)r[`return${dN}`]=(sortedRows[i+dN].close-r.close)/r.close;});
    if(prevClose!==null)trueRanges.push(Math.max(r.high-r.low,Math.abs(r.high-prevClose),Math.abs(r.low-prevClose)));
    prevClose=r.close;
    rangeHist.push(r.dailyRange);
    let cl=(Math.floor(r.dailyAvg/0.002)*0.002).toFixed(3);
    if(!clustersDaily[cl])clustersDaily[cl]={count:0,up:0,down:0,lastDate:r.dateObj,returns:[],history:[]};
    clustersDaily[cl].count++;clustersDaily[cl].up+=r.direction==="Up"?1:0;clustersDaily[cl].down+=r.direction==="Down"?1:0;
    clustersDaily[cl].lastDate=r.dateObj;clustersDaily[cl].history.push(r);
    maxDaysForExpectedReturn.forEach(dN=>{if(i+dN<sortedRows.length)clustersDaily[cl].returns.push({days:dN,ret:(sortedRows[i+dN].close-r.close)/r.close});});
    let week=getWeekNumber(r.dateObj); if(!weeklyMap[week])weeklyMap[week]=[]; weeklyMap[week].push(r);
    let clusterW=`${week}-${cl}`; if(!clustersWeekly[clusterW])clustersWeekly[clusterW]={count:0,history:[]}; clustersWeekly[clusterW].count++; clustersWeekly[clusterW].history.push(r);
    let month=getMonth(r.dateObj); if(!monthlyMap[month])monthlyMap[month]=[]; monthlyMap[month].push(r);
    let clusterM=`${month}-${cl}`; if(!clustersMonthly[clusterM])clustersMonthly[clusterM]={count:0,history:[]}; clustersMonthly[clusterM].count++; clustersMonthly[clusterM].history.push(r);
    bestDays.push({date:r.dateObj,range:r.dailyRange,avgPrice:r.dailyAvg});
  });

  const meanR=rangeHist.reduce((a,b)=>a+b,0)/rangeHist.length;
  const stdR=Math.sqrt(rangeHist.map(x=>Math.pow(x-meanR,2)).reduce((a,b)=>a+b,0)/rangeHist.length);
  bestDays.forEach(d=>d.zScore=(d.range-meanR)/stdR);
  bestDays.sort((a,b)=>b.zScore-a.zScore);
  let bestHtml='<table><tr><th>Date</th><th>Range</th><th>Z</th><th>Avg</th></tr>';
  for(let i=0;i<Math.min(10,bestDays.length);i++){
    let c=bestDays[i]; let cls=c.zScore>0?'up':'down';
    bestHtml+=`<tr><td>${c.date.toISOString().split('T')[0]}</td><td>${c.range.toFixed(4)}</td><td class="${cls}">${c.zScore.toFixed(2)}</td><td>${c.avgPrice.toFixed(4)}</td></tr>`;
  }
  bestHtml+='</table>'; document.getElementById('bestDays').innerHTML=bestHtml;

  function getConfluence(cluster){
    let d=clustersDaily[cluster]?1:0; let w=Object.keys(clustersWeekly).some(k=>k.endsWith(`-${cluster}`))?1:0; let m=Object.keys(clustersMonthly).some(k=>k.endsWith(`-${cluster}`))?1:0;
    return d+w+m;
  }

  let clusterArray=Object.keys(clustersDaily).map(c=>{
    let o=clustersDaily[c],avgR=o.history.map(d=>d.dailyRange).reduce((a,b)=>a+b,0)/o.count||0,u=o.up/o.count,rec=1/((new Date()-o.lastDate)/(1000*60*60*24)+1),conf=getConfluence(c),score=o.count*(1/avgR)*u*rec*conf;
    let exp={}; maxDaysForExpectedReturn.forEach(dN=>{let rets=o.returns.filter(x=>x.days===dN).map(x=>x.ret); let avg=rets.reduce((a,b)=>a+b,0)/rets.length||0; exp[`R${dN}`]=(avg*100).toFixed(2)+'%';});
    let range=computeExpectedRange(c,o.history);
    return {cluster:c,count:o.count,up:o.up,down:o.down,upPct:(u*100).toFixed(1)+'%',lastDate:o.lastDate.toISOString().split('T')[0],weightedScore:score.toFixed(4),confluence:conf,expectedReturns:exp,expectedHigh:range.expectedHigh,expectedLow:range.expectedLow};
  });
  clusterArray.sort((a,b)=>parseFloat(b.weightedScore)-parseFloat(a.weightedScore));
  clusterArrayGlobal=clusterArray;

  let html='<table><tr><th>Cluster</th><th>Cnt</th><th>Up</th><th>Down</th><th>Up%</th><th>Last</th><th>Score</th><th>Conf</th><th>R1</th><th>R3</th><th>R5</th><th>R10</th><th>H</th><th>L</th></tr>';
  clusterArray.slice(0,25).forEach(c=>{
    let upBadge=parseFloat(c.upPct)>50?`<span class="up">${c.upPct}</span>`:`<span class="down">${c.upPct}</span>`;
    html+=`<tr><td>${c.cluster}</td><td>${c.count}</td><td class="up">${c.up}</td><td class="down">${c.down}</td><td>${upBadge}</td><td>${c.lastDate}</td><td>${c.weightedScore}</td><td>${c.confluence}</td><td>${c.expectedReturns.R1}</td><td>${c.expectedReturns.R3}</td><td>${c.expectedReturns.R5}</td><td>${c.expectedReturns.R10}</td><td>${c.expectedHigh}</td><td>${c.expectedLow}</td></tr>`;
  });
  html+='</table>'; document.getElementById('results').innerHTML=html;

  // Next-Day Forecast
  let lastRow=sortedRows[sortedRows.length-1],lastAvg=(lastRow.open+lastRow.high+lastRow.low+lastRow.close)/4;
  let closest=clusterArray.reduce((p,c)=>Math.abs(lastAvg-parseFloat(c.cluster))<Math.abs(lastAvg-parseFloat(p.cluster))?c:p);
  let ndReturn=parseFloat(closest.expectedReturns.R1)/100+lastRow.momentum1;
  let dir=ndReturn>=0?'Up':'Down',cls=ndReturn>=0?'up':'down';
  document.getElementById('nextDayForecast').innerHTML=`<div class="${cls}">Return: ${(ndReturn*100).toFixed(2)}%, Dir: ${dir}, Cluster: ${closest.cluster}, High: ${closest.expectedHigh}, Low: ${closest.expectedLow}</div>`;

  // Weekly Forecast
  let lw=Math.max(...Object.keys(weeklyMap).map(Number)),wRows=weeklyMap[lw]||[],wAvg=wRows.length?wRows.reduce((a,b)=>a+b.dailyAvg,0)/wRows.length:0,wCl=(Math.floor(wAvg/0.002)*0.002).toFixed(3),wObj=clustersWeekly[`${lw}-${wCl}`];
  let wProb=wObj?computeProbabilisticRange(wObj.history,5):{low25:0,median50:0,high75:0};
  document.getElementById('weeklyForecast').innerHTML=`Cluster:${wCl}, Low:${(parseFloat(wCl)*(1+wProb.low25)).toFixed(4)}, Mid:${(parseFloat(wCl)*(1+wProb.median50)).toFixed(4)}, High:${(parseFloat(wCl)*(1+wProb.high75)).toFixed(4)}`;

  // Monthly Forecast
  let lm=Math.max(...Object.keys(monthlyMap).map(Number)),mRows=monthlyMap[lm]||[],mAvg=mRows.length?mRows.reduce((a,b)=>a+b.dailyAvg,0)/mRows.length:0,mCl=(Math.floor(mAvg/0.002)*0.002).toFixed(3),mObj=clustersMonthly[`${lm}-${mCl}`];
  let mProb=mObj?computeProbabilisticRange(mObj.history,20):{low25:0,median50:0,high75:0};
  document.getElementById('monthlyForecast').innerHTML=`Cluster:${mCl}, Low:${(parseFloat(mCl)*(1+mProb.low25)).toFixed(4)}, Mid:${(parseFloat(mCl)*(1+mProb.median50)).toFixed(4)}, High:${(parseFloat(mCl)*(1+mProb.high75)).toFixed(4)}`;
}

function downloadCSV(){
  if(clusterArrayGlobal.length===0){alert("Analyze first");return;}
  let csv="Cluster,Count,Up,Down,Up%,LastDate,WeightedScore,Confluence,ExpReturn1d,ExpReturn3d,ExpReturn5d,ExpReturn10d,ExpHigh,ExpLow\n";
  clusterArrayGlobal.forEach(c=>csv+=`${c.cluster},${c.count},${c.up},${c.down},${c.upPct},${c.lastDate},${c.weightedScore},${c.confluence},${c.expectedReturns.R1},${c.expectedReturns.R3},${c.expectedReturns.R5},${c.expectedReturns.R10},${c.expectedHigh},${c.expectedLow}\n`);
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}),url=URL.createObjectURL(blob),link=document.createElement('a');link.href=url;link.download="analysis.csv";document.body.appendChild(link);link.click();document.body.removeChild(link);URL.revokeObjectURL(url);
  alert("Exported!");
}
</script>
</body>
</html>
