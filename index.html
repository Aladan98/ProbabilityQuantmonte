<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Weighted OHLC Monte Carlo Forecast - Multi-Horizon</title>
</head>
<body>
<h2>Weighted OHLC Monte Carlo Forecast - Multi-Horizon</h2>
<input type="file" id="fileInput" accept=".csv">
<button id="runButton">Run Forecast</button>
<pre id="output"></pre>

<script>
let csvData = null;

// Parse CSV
function parseCSV(text) {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",").map(h => h.trim().toLowerCase());
    const oIndex = headers.indexOf("open");
    const hIndex = headers.indexOf("high");
    const lIndex = headers.indexOf("low");
    const cIndex = headers.indexOf("close");
    if([oIndex,hIndex,lIndex,cIndex].some(i => i===-1)){
        alert("CSV must contain Open, High, Low, Close columns");
        return null;
    }
    return lines.slice(1).map(line=>{
        const parts=line.split(",").map(parseFloat);
        return {o:parts[oIndex], h:parts[hIndex], l:parts[lIndex], c:parts[cIndex]};
    });
}

// Gaussian random
function gaussianRandom(){
    let u=0,v=0;
    while(u===0) u=Math.random();
    while(v===0) v=Math.random();
    return Math.sqrt(-2.0*Math.log(u))*Math.cos(2.0*Math.PI*v);
}

// Daily log returns
function calcReturns(data){
    const returns=[];
    for(let i=1;i<data.length;i++){
        returns.push(Math.log(data[i].c/data[i-1].c));
    }
    return returns;
}

// Stats
function stats(returns){
    const mean=returns.reduce((a,b)=>a+b,0)/returns.length;
    const variance=returns.reduce((a,b)=>a+(b-mean)**2,0)/returns.length;
    return {mu:mean*252, sigma:Math.sqrt(variance*252)};
}

// Simulate daily path
function simulatePath(S0, mu, sigma, horizon){
    const dt=1/252;
    const prices=[S0];
    for(let i=0;i<horizon;i++){
        const Z=gaussianRandom();
        const next=prices[prices.length-1]*Math.exp((mu-0.5*sigma*sigma)*dt + sigma*Z*Math.sqrt(dt));
        prices.push(next);
    }
    return prices;
}

// Weighted expected value
function weightedExpected(arr){
    const precision=0.01; 
    const freqMap=new Map();
    arr.forEach(p=>{
        const key=Math.round(p/precision)*precision;
        freqMap.set(key,(freqMap.get(key)||0)+1);
    });
    const total=arr.length;
    let sum=0;
    freqMap.forEach((count, price)=>{
        const prob=count/total;
        sum+=price*prob;
    });
    return sum;
}

// Percentiles
function percentile(arr,p){
    const sorted=[...arr].sort((a,b)=>a-b);
    const idx=(p/100)*(sorted.length-1);
    const lower=Math.floor(idx), upper=Math.ceil(idx);
    if(lower===upper) return sorted[lower];
    return sorted[lower]*(upper-idx)+sorted[upper]*(idx-lower);
}

// Aggregate for any horizon
function aggregateExpected(expectedDaily, span){
    const result=[];
    for(let i=0;i<expectedDaily.length;i+=span){
        result.push(weightedExpected(expectedDaily.slice(i,i+span)));
    }
    return result;
}

// Monte Carlo forecast
async function runForecast(){
    if(!csvData){alert("Upload CSV first"); return;}
    const data=parseCSV(csvData);
    if(!data) return;
    const returns=calcReturns(data);
    const {mu,sigma}=stats(returns);
    const S0=data[data.length-1].c;

    const horizon=252; // 1 year
    const simulations=50000;
    const batchSize=1000;
    const allPaths=[];

    for(let batch=0;batch<Math.ceil(simulations/batchSize);batch++){
        for(let i=batch*batchSize;i<Math.min((batch+1)*batchSize,simulations);i++){
            allPaths.push(simulatePath(S0, mu, sigma, horizon));
        }
        await new Promise(r=>setTimeout(r,10));
    }

    // Weighted expected daily prices
    const expectedDaily=[];
    for(let d=0;d<horizon+1;d++){
        const dayPrices=allPaths.map(p=>p[d]);
        expectedDaily.push(weightedExpected(dayPrices));
    }

    // Compute weighted OHLC for different horizons
    function computeOHLC(prices){
        return {
            open: prices[0],
            high: Math.max(...prices),
            low: Math.min(...prices),
            close: prices[prices.length-1]
        };
    }

    const dailyOHLC = computeOHLC(expectedDaily);
    const weeklyOHLC = computeOHLC(aggregateExpected(expectedDaily,5));
    const monthlyOHLC = computeOHLC(aggregateExpected(expectedDaily,21));
    const yearlyOHLC = computeOHLC(aggregateExpected(expectedDaily,252));

    // 95% confidence interval
    const allFinalPrices=allPaths.map(p=>p[p.length-1]);
    const lowerCI=percentile(allFinalPrices,2.5);
    const upperCI=percentile(allFinalPrices,97.5);

    document.getElementById("output").textContent=`
Start Price: $${S0.toFixed(2)}

Weighted OHLC Forecasts:
Daily:   O:${dailyOHLC.open.toFixed(2)} H:${dailyOHLC.high.toFixed(2)} L:${dailyOHLC.low.toFixed(2)} C:${dailyOHLC.close.toFixed(2)}
Weekly:  O:${weeklyOHLC.open.toFixed(2)} H:${weeklyOHLC.high.toFixed(2)} L:${weeklyOHLC.low.toFixed(2)} C:${weeklyOHLC.close.toFixed(2)}
Monthly: O:${monthlyOHLC.open.toFixed(2)} H:${monthlyOHLC.high.toFixed(2)} L:${monthlyOHLC.low.toFixed(2)} C:${monthlyOHLC.close.toFixed(2)}
Yearly:  O:${yearlyOHLC.open.toFixed(2)} H:${yearlyOHLC.high.toFixed(2)} L:${yearlyOHLC.low.toFixed(2)} C:${yearlyOHLC.close.toFixed(2)}

95% Confidence Interval (Final Price): $${lowerCI.toFixed(2)} - $${upperCI.toFixed(2)}
`;
}

document.getElementById("fileInput").addEventListener("change",(e)=>{
    const file=e.target.files[0];
    if(file){
        const reader=new FileReader();
        reader.onload=(e)=>{csvData=e.target.result;}
        reader.readAsText(file);
    }
});

document.getElementById("runButton").addEventListener("click",runForecast);
</script>
</body>
</html>
