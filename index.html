<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Realistic Tesla Monte Carlo Forecast</title>
</head>
<body>
<h2>Realistic Tesla Monte Carlo Forecast - Multi-Horizon</h2>
<input type="file" id="fileInput" accept=".csv">
<button id="runButton">Run Forecast</button>
<pre id="output"></pre>

<script>
let csvData = null;

// Parse CSV
function parseCSV(text) {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",").map(h => h.trim().toLowerCase());
    const cIndex = headers.indexOf("close");
    const oIndex = headers.indexOf("open");
    const hIndex = headers.indexOf("high");
    const lIndex = headers.indexOf("low");
    if([oIndex,hIndex,lIndex,cIndex].some(i => i===-1)){
        alert("CSV must contain Open, High, Low, Close columns");
        return null;
    }
    return lines.slice(1).map(line=>{
        const parts=line.split(",").map(parseFloat);
        return {o:parts[oIndex], h:parts[hIndex], l:parts[lIndex], c:parts[cIndex]};
    });
}

// Gaussian random
function gaussianRandom(){
    let u=0,v=0;
    while(u===0) u=Math.random();
    while(v===0) v=Math.random();
    return Math.sqrt(-2.0*Math.log(u))*Math.cos(2.0*Math.PI*v);
}

// Daily log returns
function calcReturns(data){
    const returns=[];
    for(let i=1;i<data.length;i++){
        returns.push(Math.log(data[i].c/data[i-1].c));
    }
    return returns;
}

// Stats
function stats(returns){
    const mean=returns.reduce((a,b)=>a+b,0)/returns.length;
    const variance=returns.reduce((a,b)=>a+(b-mean)**2,0)/returns.length;
    return {mu:mean*252, sigma:Math.sqrt(variance*252)};
}

// Simulate daily path with capped shocks
function simulatePath(S0, mu, sigma, horizon){
    const dt=1/252;
    const prices=[S0];
    for(let i=0;i<horizon;i++){
        let Z = gaussianRandom();
        Z = Math.max(Math.min(Z,3),-3); // cap ±3σ
        const next = prices[prices.length-1]*Math.exp((mu-0.5*sigma*sigma)*dt + sigma*Z*Math.sqrt(dt));
        prices.push(next);
    }
    return prices;
}

// Median function
function median(arr){
    const sorted = [...arr].sort((a,b)=>a-b);
    const mid = Math.floor(sorted.length/2);
    return sorted.length % 2 === 0 ? (sorted[mid-1]+sorted[mid])/2 : sorted[mid];
}

// Pathwise OHLC
function pathwiseOHLC(paths) {
    return paths.map(path => ({
        open: path[0],
        high: Math.max(...path),
        low: Math.min(...path),
        close: path[path.length-1]
    }));
}

// Median OHLC across paths
function medianOHLC(ohlcArray) {
    return {
        open: median(ohlcArray.map(p => p.open)),
        high: median(ohlcArray.map(p => p.high)),
        low: median(ohlcArray.map(p => p.low)),
        close: median(ohlcArray.map(p => p.close))
    };
}

// Aggregate paths for multi-horizon
function aggregatePaths(paths, span){
    const aggregated = [];
    for(let path of paths){
        const result = [];
        for(let i=0;i<path.length;i+=span){
            result.push(median(path.slice(i,i+span)));
        }
        aggregated.push(result);
    }
    return aggregated;
}

// Percentiles
function percentile(arr,p){
    const sorted=[...arr].sort((a,b)=>a-b);
    const idx=(p/100)*(sorted.length-1);
    const lower=Math.floor(idx), upper=Math.ceil(idx);
    if(lower===upper) return sorted[lower];
    return sorted[lower]*(upper-idx)+sorted[upper]*(idx-lower);
}

// Monte Carlo forecast
async function runForecast(){
    if(!csvData){alert("Upload CSV first"); return;}
    let data=parseCSV(csvData);
    if(!data) return;

    // Use only last 126 trading days (~6 months)
    if(data.length>126) data = data.slice(data.length-126);

    const returns=calcReturns(data);
    const {mu,sigma}=stats(returns);
    const S0=data[data.length-1].c;

    const horizon=252; // 1 year
    const simulations=50000;
    const batchSize=1000;
    const allPaths=[];

    for(let batch=0;batch<Math.ceil(simulations/batchSize);batch++){
        for(let i=batch*batchSize;i<Math.min((batch+1)*batchSize,simulations);i++){
            allPaths.push(simulatePath(S0, mu, sigma, horizon));
        }
        await new Promise(r=>setTimeout(r,10));
    }

    // Multi-horizon OHLC
    const dailyPathOHLC = pathwiseOHLC(allPaths);
    const dailyOHLC = medianOHLC(dailyPathOHLC);

    const weeklyPaths = aggregatePaths(allPaths,5);
    const monthlyPaths = aggregatePaths(allPaths,21);
    const yearlyPaths = aggregatePaths(allPaths,252);

    const weeklyOHLC = medianOHLC(pathwiseOHLC(weeklyPaths));
    const monthlyOHLC = medianOHLC(pathwiseOHLC(monthlyPaths));
    const yearlyOHLC = medianOHLC(pathwiseOHLC(yearlyPaths));

    // Forecast central price = median of final prices
    const allFinalPrices=allPaths.map(p=>p[p.length-1]);
    const forecastPrice = median(allFinalPrices);
    const lowerCI=percentile(allFinalPrices,2.5);
    const upperCI=percentile(allFinalPrices,97.5);

    document.getElementById("output").textContent=`    
Start Price: $${S0.toFixed(2)}

Forecast Median Price (1Y): $${forecastPrice.toFixed(2)}

Median OHLC Forecasts:
Daily:   O:${dailyOHLC.open.toFixed(2)} H:${dailyOHLC.high.toFixed(2)} L:${dailyOHLC.low.toFixed(2)} C:${dailyOHLC.close.toFixed(2)}
Weekly:  O:${weeklyOHLC.open.toFixed(2)} H:${weeklyOHLC.high.toFixed(2)} L:${weeklyOHLC.low.toFixed(2)} C:${weeklyOHLC.close.toFixed(2)}
Monthly: O:${monthlyOHLC.open.toFixed(2)} H:${monthlyOHLC.high.toFixed(2)} L:${monthlyOHLC.low.toFixed(2)} C:${monthlyOHLC.close.toFixed(2)}
Yearly:  O:${yearlyOHLC.open.toFixed(2)} H:${yearlyOHLC.high.toFixed(2)} L:${yearlyOHLC.low.toFixed(2)} C:${yearlyOHLC.close.toFixed(2)}

95% Confidence Interval (Final Price): $${lowerCI.toFixed(2)} - $${upperCI.toFixed(2)}
`;
}

document.getElementById("fileInput").addEventListener("change",(e)=>{
    const file=e.target.files[0];
    if(file){
        const reader=new FileReader();
        reader.onload=(e)=>{csvData=e.target.result;}
        reader.readAsText(file);
    }
});

document.getElementById("runButton").addEventListener("click",runForecast);
</script>
</body>
</html>
